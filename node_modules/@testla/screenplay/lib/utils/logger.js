"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.indentationLevelDown = exports.indentationLevelUp = exports.skipOnFailLevelDown = exports.skipOnFailLevelUp = void 0;
const constants_1 = require("../constants");
const Question_1 = require("../screenplay/Question");
const call_stack_1 = require("./call-stack");
/**
 * Current skipOnFail level
 */
let skipOnFailLevel = 0;
/**
 * Highers the skipOnFailLevel level
 */
const skipOnFailLevelUp = () => { skipOnFailLevel += 1; };
exports.skipOnFailLevelUp = skipOnFailLevelUp;
/**
 * Lowers the skipOnFailLevel level
 */
const skipOnFailLevelDown = () => { skipOnFailLevel -= 1; };
exports.skipOnFailLevelDown = skipOnFailLevelDown;
/**
 * Current indentation level
 */
let indentationLevel = 0;
/**
 * Highers the indentation level
 */
const indentationLevelUp = () => { indentationLevel += 1; };
exports.indentationLevelUp = indentationLevelUp;
/**
 * Lowers the indentation level
 */
const indentationLevelDown = () => { indentationLevel -= 1; };
exports.indentationLevelDown = indentationLevelDown;
/**
 * Indents a message based on the indentation level
 * @param msg the message to be indented
 * @param level the indentation level
 * @returns final formatted message
 */
const blankifyMsg = (msg, level) => {
    let finalMsg = msg;
    for (let i = 0; i <= level * constants_1.LOGGING_BLANKS_PER_INDENTATION_LEVEL; i += 1) {
        finalMsg = ` ${finalMsg}`;
    }
    return finalMsg;
};
/**
 * @returns current time (UTC)
 */
const printCurrentTime = () => (new Date())
    .toISOString()
    .substring(11, 23);
/**
 * @param status of the activity
 * @returns status badge
 */
const printStatus = (status) => {
    let badge = '';
    switch (status) {
        case constants_1.EXEC_STATUS.START:
            badge = 'EXEC';
            break;
        case constants_1.EXEC_STATUS.FAILED:
            badge = `${skipOnFailLevel === 0 ? constants_1.BASH_COLOR.RED_BG : ''}FAIL`;
            break;
        case constants_1.EXEC_STATUS.SKIPPED:
            badge = 'SKIP';
            break;
        default:
            badge = 'DONE';
    }
    return `${badge}${constants_1.BASH_COLOR.RESET}`;
};
/**
 * Writes the log information directly to stdout
 * @param actor THe actor who triggered an executable
 * @param element The executable
 */
const log = (actor, element, status) => {
    var _a, _b, _c;
    if (!((_a = process.env.DEBUG) === null || _a === void 0 ? void 0 : _a.includes(constants_1.LOGGING_IDENTIFIER))) {
        return undefined;
    }
    const isQuestion = element instanceof Question_1.Question;
    const msg = `${status !== constants_1.EXEC_STATUS.FAILED ? (isQuestion ? '✔️' : '↪') : '✗'} ${actor.attributes.name} ${isQuestion ? 'asks' : 'attemptsTo'} ${element.constructor.name}${(0, call_stack_1.printCallStack)((_b = element.getCallStack) === null || _b === void 0 ? void 0 : _b.call(element))}`;
    const color = status === constants_1.EXEC_STATUS.FAILED && skipOnFailLevel === 0 ? constants_1.BASH_COLOR.RED : constants_1.BASH_COLOR.RESET;
    const msgActivityAndFile = `${msg}  ${constants_1.BASH_COLOR.GRAY}${(0, call_stack_1.printFilePath)((_c = element.getCallStack) === null || _c === void 0 ? void 0 : _c.call(element))}${constants_1.BASH_COLOR.RESET}`;
    process.stdout.write(`${constants_1.LOGGING_BASE_INDENTATION}${constants_1.BASH_COLOR.BLUE}testla:sp${constants_1.BASH_COLOR.GRAY} ${printCurrentTime()}  ${printStatus(status)}${color} ${blankifyMsg(msgActivityAndFile, indentationLevel)}\n`);
    return msgActivityAndFile;
};
exports.default = log;
